<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>MaxRL Weight Functions - Interactive Plot</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --cmu-red: #C41230;
            --cmu-red-light: rgba(196, 18, 48, 0.2);
            --blue: #0056b3;
            --blue-light: rgba(0, 86, 179, 0.2);
            --gold: #ffb000;
            --gold-light: rgba(255, 176, 0, 0.2);
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            /* Task: Use a clean white page background and make the component stand out. */
            background-color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
        }

        .container {
            width: 800px;
            background: #ffffff; /* keep card itself pure white */
            padding: 40px;
            border-radius: 16px;
            /* Task: Use a slightly stronger, brand-colored border to emphasize the component. */
            border: 2px solid rgba(196, 18, 48, 1); /* soft CMU red accent */
            /* Task: Use a global, even shadow around the card instead of a bottom drop shadow. */
            text-align: center;
        }

        .chart-container {
            position: relative;
            height: 400px; /* Task: Make the figure taller for better readability. */
            margin-bottom: 30px;
        }

        .tab-group {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .tab {
            padding: 12px 25px;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            background: #f5f5f5;
            color: #888;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Task: Vertically center main and sub labels inside each pill. */
            justify-content: center;
            line-height: 1.2;
            /* Task: Ensure all three tabs have the same visual width so the group looks centered.
               Implementation: use a fixed flex-basis and prevent shrinking. */
            flex: 0 0 170px;
            box-sizing: border-box;
        }

        .tab-title {
            /* Task: Make main tab label slightly larger for emphasis. */
            font-size: 16px;
        }

        .tab-sub {
            /* Task: Increase spacing between main label and sub label,
               and make sub label color slightly darker for readability. */
            font-size: 14px;
            font-weight: normal;
            color: #777;
            margin-top: 8px;
        }

        /* When tab is active, ensure sub label follows active (white) color as well. */
        .tab.active .tab-sub {
            /* Use !important to override any inherited/MathJax styles. */
            color: white !important;
        }

        /* Hover state: use each mode's own color to hint interactivity. */
        .tab[data-mode="rl"]:hover { border-color: var(--blue); color: var(--blue); }
        .tab[data-mode="maxrl"]:hover { border-color: var(--cmu-red); color: var(--cmu-red); }
        .tab[data-mode="ml"]:hover { border-color: var(--gold); color: var(--gold); }

        /* Ensure sub labels follow hover color for better visual cue. */
        .tab[data-mode="rl"]:hover .tab-sub { color: var(--blue); }
        .tab[data-mode="maxrl"]:hover .tab-sub { color: var(--cmu-red); }
        .tab[data-mode="ml"]:hover .tab-sub { color: var(--gold); }

        .tab[data-mode="rl"].active { background: var(--blue); color: white; }
        .tab[data-mode="maxrl"].active { background: var(--cmu-red); color: white; }
        .tab[data-mode="ml"].active { background: var(--gold); color: white; }

        #slider-area {
            margin-top: 25px;
            padding: 15px;
            background: #fafafa;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        input[type=range] {
            flex: 1;
            accent-color: var(--cmu-red);
        }

        .val-text { font-family: monospace; font-weight: bold; color: var(--cmu-red); width: 40px; }
    </style>
</head>
<body>

<div class="container">
    <h2 style="margin-top:0; color:#333;">Weight Functions</h2>
    
    <div class="chart-container">
        <canvas id="vizChart"></canvas>
    </div>

    <!-- Legend will now be rendered inside the chart area via Chart.js. -->

    <div class="tab-group">
        <!-- Task: Center three buttons with MaxRL in the middle, and add a second-line description matching vis_weight.html. -->
        <div class="tab" data-mode="rl" onclick="setMode('rl')">
            <span class="tab-title">Standard RL</span>
            <span class="tab-sub">\(T = 1\)</span>
        </div>
        <div class="tab active" data-mode="maxrl" onclick="setMode('maxrl')">
            <span class="tab-title">MaxRL</span>
            <span class="tab-sub">\(T = N\)</span>
        </div>
        <div class="tab" data-mode="ml" onclick="setMode('ml')">
            <span class="tab-title">Maximum Likelihood</span>
            <span class="tab-sub">\(T \to \infty\)</span>
        </div>
    </div>


    <div id="regime-caption" style="margin-top: 20px; font-size: 14px; color:#555; min-height: 1.4em;">
        \(T = N\) (number of rollouts) is what we use in practice.
    </div>

    <div id="slider-area">
        <span style="font-size: 14px; color:#666;">Parameter \(T\)</span>


        <input type="range" id="t-slider" min="0" max="12" step="1" value="5">
        <span id="t-display" class="val-text">32</span>
    </div>
</div>

<script>
    const ctx = document.getElementById('vizChart').getContext('2d');
    const tSlider = document.getElementById('t-slider');
    const tDisplay = document.getElementById('t-display');
    const sliderArea = document.getElementById('slider-area');

    let activeMode = 'maxrl';

    // Task: Use the same mathematical weight functions as in plot.py and keep x,y on log scales.
    // Implementation: sample p in [1e-3, 1 - 1e-3] (log-spaced), then compute:
    //  - J_ML(p)   = 1 / p
    //  - J_GRPO(p) = 1 / sqrt(p (1 - p))
    //  - J_MaxRL^T(p) = (1 - (1 - p)^T) / p

    // Non-linear mapping from slider position to T (English comments as requested).
    // Task: Add more T values to better interpolate toward infinity.
    const T_VALUES = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, Infinity];

    // Core color theme for RL / MaxRL / ML / GRPO.
    const theme = {

        grpo: { normal: '#9BC794', light: 'rgba(155, 199, 148, 0.6)' },
        rl:   { normal: '#0056b3', light: 'rgba(0, 86, 179, 0.4)' },
        maxrl: { normal: '#C41230', light: 'rgba(196, 18, 48, 0.4)' },
        ml: { normal: '#ffb000', light: 'rgba(255, 176, 0, 0.4)' }
    };

    // Task: Draw a compact legend inside the chart area instead of below the plot.
    // Implementation: use a custom plugin to render colored line segments + labels in the top-right corner.
    const inChartLegend = {
        id: 'inChartLegend',
        afterDraw(chart, args, opts) {
            const { ctx, chartArea } = chart;
            if (!chartArea) return;

            const { top, right } = chartArea;

            // Legend items and their colors should match the datasets and textual legend semantics.
            const items = [
                { label: 'MaxRL', color: theme.maxrl.normal },
                { label: 'Standard RL', color: theme.rl.normal },
                { label: 'GRPO', color: theme.grpo.normal },
                { label: 'Maximum Likelihood', color: theme.ml.normal },
            ];

            ctx.save();

            const fontSize = 12;
            ctx.font = `${fontSize}px "Helvetica Neue", Arial, sans-serif`;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';

            let y = top + 18;
            // Task: Shift in-chart legend slightly left to avoid overlapping with axis labels.
            const x = right - 40;           // anchor text a bit further left
            const lineLength = 26;
            const lineOffset = -10;          // distance from text to start of line

            items.forEach((item) => {
                // Draw line segment with the series color.
                ctx.strokeStyle = item.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x - lineOffset, y);
                ctx.lineTo(x - lineOffset + lineLength, y);
                ctx.stroke();

                // Draw label text.
                ctx.fillStyle = '#333';
                ctx.fillText(item.label, x, y);

                y += 18; // vertical spacing between legend entries
            });

            ctx.restore();
        }
    };

    // Generate log-spaced p values in (0, 1).
    function generatePValues(n, pMin, pMax) {
        const ps = [];
        const logMin = Math.log(pMin);
        const logMax = Math.log(pMax);
        for (let i = 0; i < n; i++) {
            const t = i / (n - 1);
            const logP = logMin + (logMax - logMin) * t;
            ps.push(Math.exp(logP));
        }
        return ps;
    }

    const N_POINTS = 400;
    const P_MIN = 1e-3;
    const P_MAX = 1 - 1e-3;
    const pValues = generatePValues(N_POINTS, P_MIN, P_MAX);

    function wML(p) {
        return 1.0 / p;
    }

    function wGRPO(p) {
        return 1.0 / Math.sqrt(p * (1.0 - p));
    }

    function wMaxRL(p, T) {
        // For T = ∞, approximate with a very large T to avoid numerical issues.
        const effectiveT = (T === Infinity) ? 1e6 : T;
        return (1.0 - Math.pow(1.0 - p, effectiveT)) / p;
    }

    // Standard RL is recovered at T = 1 (same functional form as MaxRL with fixed T = 1).
    function getRLData() {
        return pValues.map(p => ({ x: p, y: wMaxRL(p, 1) }));
    }

    function getMLData() {
        return pValues.map(p => ({ x: p, y: wML(p) }));
    }

    function getGRPOData() {
        return pValues.map(p => ({ x: p, y: wGRPO(p) }));
    }

    function getMaxRLData(T) {
        return pValues.map(p => ({ x: p, y: wMaxRL(p, T) }));
    }

    // Initialize chart with log–log axes and three curves.
    const chart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [
                {
                    // MaxRL with adjustable T (drawn first so it is conceptually primary).
                    label: 'J_MaxRL^{(T)}',
                    data: getMaxRLData(T_VALUES[5]),    // default T = 32
                    borderColor: theme.maxrl.normal,
                    borderWidth: 4,
                    pointRadius: 0,
                    tension: 0,
                    parsing: false
                },
                {
                    // Standard RL corresponds to MaxRL with T = 1.
                    label: 'J_RL',
                    data: getRLData(),
                    borderColor: theme.rl.normal,
                    borderWidth: 3,
                    pointRadius: 0,
                    tension: 0,
                    parsing: false
                },
                {
                    // GRPO baseline, always shown in green without its own toggle.
                    label: 'J_GRPO',
                    data: getGRPOData(),
                    borderColor: theme.grpo.normal,
                    borderWidth: 2.5,
                    pointRadius: 0,
                    tension: 0,
                    parsing: false
                },
                {
                    // Maximum Likelihood.
                    label: 'J_ML',
                    data: getMLData(),
                    borderColor: theme.ml.normal,
                    borderWidth: 3,
                    pointRadius: 0,
                    tension: 0,
                    parsing: false
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 300 },
            scales: {
                x: {
                    type: 'logarithmic',
                    min: P_MIN,
                    max: 1,
                    grid: {
                        color: 'rgba(0,0,0,0.06)'
                    },
                    // Task: Use clearer math-like axis labels.
                    title: {
                        display: true,
                        text: 'Pass Rate', // pθ(x)
                        font: {
                            size: 16,
                            family: 'Helvetica Neue, Arial, sans-serif'
                        }
                    },
                    ticks: {
                        font: {
                            size: 14,
                            family: 'Helvetica Neue, Arial, sans-serif'
                        },
                        callback: function(value) {
                            const v = Number(value);
                            if (v === 1e-3 || v === 1e-2 || v === 1e-1 || v === 1) {
                                // Avoid 1e-? style; use decimal notation like 0.1.
                                if (v === 1) return '1';
                                if (v === 1e-1) return '0.1';
                                if (v === 1e-2) return '0.01';
                                if (v === 1e-3) return '0.001';
                            }
                            return '';
                        }
                    }
                },
                y: {
                    type: 'logarithmic',
                    min: 1,
                    max: 1e3,
                    grid: {
                        color: 'rgba(0,0,0,0.06)'
                    },
                    title: {
                        display: true,
                        text: 'Weight',
                        font: {
                            size: 16,
                            family: 'Helvetica Neue, Arial, sans-serif'
                        }
                    },
                    ticks: {
                        font: {
                            size: 14,
                            family: 'Helvetica Neue, Arial, sans-serif'
                        },
                        callback: function(value) {
                            const v = Number(value);
                            if (v === 1 || v === 1e1 || v === 1e2 || v === 1e3) {
                                // Avoid 1e style; render as plain integers.
                                if (v === 1) return '1';
                                if (v === 1e1) return '10';
                                if (v === 1e2) return '100';
                                if (v === 1e3) return '1000';
                            }
                            return '';
                        }
                    }
                }
            },
            // Disable built-in legend; we draw a custom legend inside the chart area via plugin.
            plugins: {
                legend: {
                    display: false
                }
            }
        },
        plugins: [inChartLegend]
    });

    function setMode(mode) {
        activeMode = mode;

        // Update tab UI
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelector(`.tab[data-mode="${mode}"]`).classList.add('active');

        // Update caption text to describe the current T-regime (MathJax-rendered).
        const captionEl = document.getElementById('regime-caption');
        if (captionEl) {
            if (mode === 'rl') {
                captionEl.innerHTML = '\\(T = 1\\) recovers standard reinforcement learning (pass@1).';
            } else if (mode === 'ml') {
                captionEl.innerHTML = '\\(T \\to \\infty\\) recovers exact maximum likelihood.';
            } else {
                captionEl.innerHTML = '\\(T = N\\) (number of rollouts) is what we use in practice.';
            }
            if (window.MathJax && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise([captionEl]);
            }
        }

        // Task: Keep slider always visible; only change which curve is visually emphasized.
        chart.data.datasets.forEach((ds, idx) => {
            // New dataset index mapping: 0 = MaxRL, 1 = RL, 2 = GRPO, 3 = ML.
            if (idx === 0) {
                ds.borderColor = (mode === 'maxrl') ? theme.maxrl.normal : theme.maxrl.light;
                ds.borderWidth = (mode === 'maxrl') ? 4 : 2.5;
                ds.zIndex = (mode === 'maxrl') ? 10 : 2;
            } else if (idx === 1) {
                ds.borderColor = (mode === 'rl') ? theme.rl.normal : theme.rl.light;
                ds.borderWidth = (mode === 'rl') ? 4 : 2.5;
                ds.zIndex = (mode === 'rl') ? 10 : 2;
            } else if (idx === 2) {
                // GRPO is always shown in the same green style.
                ds.borderColor = theme.grpo.normal;
                ds.borderWidth = 2.5;
                ds.zIndex = 1;
            } else if (idx === 3) {
                ds.borderColor = (mode === 'ml') ? theme.ml.normal : theme.ml.light;
                ds.borderWidth = (mode === 'ml') ? 4 : 2.5;
                ds.zIndex = (mode === 'ml') ? 10 : 2;
            }
        });

        chart.update();
    }

    tSlider.oninput = function() {
        const idx = parseInt(this.value, 10);
        const T = T_VALUES[idx];
        const displayT = (T === Infinity) ? '∞' : T.toString();
        tDisplay.innerText = displayT;

        // Task: Slider should always control the MaxRL curve, regardless of active toggle.
        // With new ordering, dataset index 0 corresponds to the MaxRL^{(T)} curve.
        chart.data.datasets[0].data = getMaxRLData(T);
        chart.update('none'); // No animation during slider drag for smooth interaction.
    };

    // Initialization: set default mode to MaxRL and ensure UI is in sync.
    setMode('maxrl');
</script>

</body>
</html>